package main

import (
	"errors"
	"fmt"

	"github.com/sirupsen/logrus"
)

func main() {
	num := int64(500)

	n, err := setBit(num, 1, false)
	if err != nil {
		return
	}

	fmt.Println(n)
}

// Функция принимает число (n int64) в котором нужно заменить
// i-бит (p int) на 1 или 0 (b bool - true и false соответственно).
// В качестве значения для n int64 используйте число из диапазона
// от 0 до 63.
func setBit(n int64, p int, b bool) (int64, error) {
	if p < 0 || p > 63 {
		logrus.Error("out of range: use from 0 to 63 to select a position")
		return n, errors.New("out of range")
	}

	// Чтобы установить i-й бит в нужное значение нужно
	// выбрать значение (1) и число позиций на которое
	// мы смещаем данное значение. В зависимости от
	// использованного оператора (| или &) смещенный бит
	// будет принимать нужное нам значение.

	// Чтобы установить i-й бит - используем оператор OR (|)
	// Главная идея в том, чтобы правый операнд был таким,
	// чтобы при применении к нему OR или AND мы преобразовывали
	// в желаемый вид.
	if b {
		// Оператор | копирует бит, если тот задан в одном из
		// операндов (т.е. справа и слева от |=) и т.к. операнд
		// справа всегда равен 1, то мы всегда устанавливаем 1.
		n |= (1 << p)
	} else { //  Чтобы сбросить i-й бит - оператор AND (&)
		// Оператор & копирует бит, если тот задан в обоих операндах.
		// т.е. 0 будет во всех случаях кроме 1 &= 1.
		// чтобы исключить этот случай используем оператор XOR (^)
		// который копирует бит если тот задан только в одном
		// операнде, в остальных случаях он сбрасывает бит - и т.к.
		n &= ^(1 << p)
	}
	return n, nil
}
